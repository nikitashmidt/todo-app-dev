<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      http-equiv="X-UA-Compatible"
      content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="style.css" />
    <title>Заметки Фронтендера</title>
  </head>
  <body>
      <div class="menu">
         <div class="menu-right">
           <div class="hamburger">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor"><path fill="currentColor" fillRule="evenodd" d="M0 11a1 1 0 0 1 1-1h22a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1ZM0 19a1 1 0 0 1 1-1h22a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1ZM0 3a1 1 0 0 1 1-1h22a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Z" clipRule="evenodd"/>
            </svg>
         </div>
         </div>
         <div class="count"></div>
      </div>

      <ul class="menu-list">
        <div class="menu-list-svg">
          <?xml version="1.0" encoding="utf-8"?>
          <svg fill="#000000" width="30px" height="30px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
           <path d="M18.8,16l5.5-5.5c0.8-0.8,0.8-2,0-2.8l0,0C24,7.3,23.5,7,23,7c-0.5,0-1,0.2-1.4,0.6L16,13.2l-5.5-5.5  c-0.8-0.8-2.1-0.8-2.8,0C7.3,8,7,8.5,7,9.1s0.2,1,0.6,1.4l5.5,5.5l-5.5,5.5C7.3,21.9,7,22.4,7,23c0,0.5,0.2,1,0.6,1.4  C8,24.8,8.5,25,9,25c0.5,0,1-0.2,1.4-0.6l5.5-5.5l5.5,5.5c0.8,0.8,2.1,0.8,2.8,0c0.8-0.8,0.8-2.1,0-2.8L18.8,16z"/>
          </svg>
        </div>
        <li> <a href="react.html"> React </a> </li>
        <li> <a href="algoritms.html">Algoritms</a></li>
      </ul>

    <div class="container">
      <div class="block">
        <div class="title">Типы данных в JS [8] </div>
        <div class="description">
            <ol class="description-par">
              <li>String</li>
              <li>Number</li>
              <li>Bigint</li>
              <li>Boolean</li>
              <li>Undefined</li>
              <li>Null</li>
              <li>Symbol</li>
              <li>Object</li>
            </ol>
        </div>
      </div>

      <div class="block">
        <div class="title"> Ссылочный тип данных / примитивный </div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Ссылочный тип данных</span> отличается от примитивного типа данных тем, 
            что переменная, 
            которая содержит ссылочный тип данных, 
            не хранит само значение, а лишь ссылку на место в памяти.
            <br>
             При присваивании значения другой переменной, 
            она не копирует значение, а лишь ссылку на место в памяти, где хранится это значение.
             <div class="divider"></div>
            А <span class="bold">примитивы</span> хранятся в памяти напрямую в переменной,
             которая содержит это значение. <br>
            При присваивании значения другой переменной, значение переменной копируется.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title"> Различие null / Undefined </div>
        <div class="description">
          <div class="description-par"> 
            <span class="bold"> Undefined </span> -  означает, что переменная была объявлена
            но ей не было присвоено какое-либо значение. 
            <br>
            <span class="bold">Undefined</span> - также может быть возвращено функцией, если она 
            не возвращает явное значение. 
            <br>
            <span class="bold">Undefined</span> - является дефолтным значением для параметров функции
            <div class="divider" > </div>
            <span class="bold">Null</span> - означет, что значение переменной явно установлено,
            как ничего
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title"> Различие function declaration / fn expression  </div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Function declaration</span> - объявление функции, которое начинается с ключевого слова function,
            за которые следует имя функции, а затем тело самой функции.
            <br>
            Благодаря механизму <span class="bold">«Поднятие / Hoisting»</span> данный вид функций можно вызывать в любом месте документа.
            <div class="divider"></div>
            <span class="bold">Function expression</span> - эта функция, которая объявлена с помощью
            переменной и не может быть вызвана до ее объявления.
            <div class="divider"></div>
            Основная разница заключается в том, что function declaration создаются до выполнения 
            кода, в том время, как fn expression создается во время выполнения кода.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Различие между const, let, var</div>
        <div class="description">
          <div class="description-par">
           <div class="bold">1.</div> Переменные объявленные через <span class="bold">var</span> всплывают, это значит, что если мы
            обратимся к переменной еще до момента ее объявления, то получим просто undefined
            в случае же с let и const мы увидем ошибки.
            <div class="divider"></div>
            <div class="bold">2.</div> У них есть разная область видимости, у let и const область видимости -
            <div class="bold">блочная</div>, а у var она функциональная и за блоком var будет все равно доступна.
            <div class="divider"></div>
            <div class="bold">3.</div> Разница между let и const заключается в том, что переменная
            объявленая через сonst становится константой и по идее ее невозможно переопределить, при 
            попытке это сделать мы получим ошибку, при этом мы можем изменять значение свойства обьекта
            объявленные через const, но не переопределить полностью объект. 

          </div>
        </div>
      </div>

      <div  class="block">
        <div class="title">Что такое Hoisting / Поднятие </div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Hoisting</span> - это механизм в JavaScript, в котором переменные и 
            объявления функций (fn declaration), 
            передвигаются вверх своей области видимости перед тем, как код будет выполнен.
            <div class="divider"></div>
            <div class="bold">JavaScript</div> - сначала объявляет, а уже затем инициализирует наши
            переменные, а это значит, что к переменным объявленные через var, а также к функциям 
            объявленным, как function declaration можно получить доступ еще до объявления
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title"> Область видимости «Scope» </div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Область видимости</span> -  в JavaScript определяет доступность переменных и 
            функций в различных частях кода. Область видимости определяет, 
            где и какие переменные и функции могут быть использованы в коде.
            <div class="divider"></div>
            Существует 3 типа <span class="bold">Областей видимости</span>
            <br>
           <span class="bold"> 1. Глобальная </span>  - переменные и функции в данной области становятся
           глобальными и доступны в любом месте документа.
           <div class="divider"></div>
           <span class="bold">2. Фунциональная / локальная</span> - переменные и функции объявленные
           внутри функций доступны только этой функции и всем вложенным в нее функциям.
           <div class="divider"></div>
           <span class="bold">3. Блочная область видимости </span> - появилась в ES6, для переменных
           объявленных с помощью let и const, такая область видимости находится внутри фигурных скобок
           так называемого блока, даже если это обычный блок if / else, и эти переменные не будут доступны
           за пределом этой области видимости.
          </div>
        </div>
      </div>

      
      <div class="block">
        <div class="title">Что такое замыкания ? «Closure»</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Замыкание</div> возникает, когда функция внутри другой функции использует переменные из 
            внешней функции. В этом случае внутренняя функция сохраняет ссылку на 
            внешнюю область видимости, и переменные из этой области видимости могут 
            быть использованы внутри внутренней функции, даже после того, как 
            внешняя функция завершила свою работу.
          </div>
        </div>
      </div>


      <div class="block">
        <div class="title"> Что обозначает ключевое слово «this»</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">This </div > -  это ключевое слово, которое ссылается на
               текущий объект, в контексте которого выполняется код. 
              Значение this зависит от того, как вызывается функция или метод. 
            <div class="divider"></div>
            Например, если функция вызывается как метод объекта, то this ссылается 
            на этот объект. Если функция вызывается без контекста, то this ссылается
             на глобальный объект (window). 
             Если функция вызывается с использованием конструктора, то this ссылается на новый экземпляр объекта, созданный с помощью конструктора. 
              <div class="divider"></div>
              <div class="bold">Стрелочная функция </div> не имеет собственного контекста и если в 
              таком случае прописать
               this то ссылаться ключевое слово будет на объект ближайший по иерархии. 
               Такая особенность удобна, когда мы хотим передать в функцию внешний контекст.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Функция-конструктор</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Функция-конструктор</div> - позволяет создавать новые объекты по шаблону на основе других данных.
             При вызове функции конструктора this принимает значение вновь созданного объекта, 
             который наполняется вследствие выполнения тела функции.
             <div class="code">
              function Student(name, course) { <br>
                this.name = name <br>
                this.course = course <br>
                this.school = 'LearnJS' <br>
              } 
              <br>
              let student1 = new Student('Вера', 'JavaScript Basic') <br>
             </div>
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Рекурсия</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Рекурсия</div> - это процесс, при котором функция вызывает саму себя
            в своем теле. Для выхода из функции должно быть обязательно условие.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Promise</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Promise</div> - это объект, который используется для выполнения асинхронных операций и 
            управления их результатами. 
            <div class="divider"></div>
            Promise может находиться в трех состояниях: ожидание <div class="bold">pending</div>, 
            выполнено <div class="bold">fulfilled</div> или отклонено <div class="bold">rejected</div>.
            <div class="divider"></div>
            <div class="bold">Promise</div> позволяет управлять асинхронными операциями с 
            помощью методов then(), catch() и finally().
            <div class="divider"></div>
            <div class="bold">Promise</div> получает два аргумента: resolve и reject — это функции, встроенные в JavaScript.
            <br>
             <div class="bold">Resolve</div> если работа завершилась успешно, с результатом value.
             <br>
              <div class="bold">Reject</div> если произошла ошибка, error – объект ошибки.
             <div class="divider"></div>
             Первый аргумент метода <div class="bold">.then</div> - функция, которая выполняется, когда промис 
             переходит в состояние «fulfield», и получает результат.
            <br>
            Второй аргумент <div class="bold">.then</div> – функция, которая выполняется, когда промис переходит в 
            состояние «rejected», и получает ошибку.
             <br>
             <div class="divider"></div>
             Также ошибку мы можем получить в отдельной функции - 
             <div class="bold">.catch</div>, которая выполняется, когда промис переход 
             в состояние «rejected». <br>
             <div class="bold">.finally</div> - функция, которая выполнится в любом случае.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Promise API</div>
        <div class="description">
          <div class="description-par">
            В классе <div class="bold">Promise</div> есть несколько статических методов.
            <div class="divider"></div>
            <div class="bold">Promise.all</div> - принимает массив промисов (может принимать 
            любой перебираемый объект, но обычно используется массив)
             и возвращает новый промис.
            Новый промис завершится, когда завершится весь переданный список промисов, 
            и его результатом будет массив их результатов.
            
            Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, 
            полностью забывая про остальные промисы в списке. Их результаты игнорируются.
            <div class="code">
              let promise = Promise.all(iterable);
            </div>
            <div class="divider"></div>
            <div class="bold">Promise.race</div> - Метод очень похож на Promise.all, но ждёт
             только первый выполненный промис, из которого берёт результат (или ошибку).
            <div class="code">let promise = Promise.race(iterable);            </div>
            <div class="divider"></div>
            <div class="bold">Promise.any</div> - Метод очень похож на Promise.race, но ждёт 
            только первый успешно выполненный промис, из которого берёт результат.
            <br>
            Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.
            <div class="code">let promise = Promise.any(iterable);
            </div>
            <div class="divider"></div>
            <div class="bold">Promise.resolve(value)</div> - создаёт успешно выполненный промис с результатом value.
            <div class="code">let promise = new Promise(resolve => resolve(value));
            </div>
            <div class="divider"></div>
            <div class="bold">Promise.reject(error)</div> - создаёт промис, завершённый с ошибкой error.
            <div class="code">let promise = new Promise((resolve, reject) => reject(error));
            </div>
          </div>
        </div>
      </div>


      <div class="block">
        <div class="title">Async / await</div>
        <div class="description">
          <div class="description-par">
            Существует специальный синтаксис для работы с промисами, который называется <div class="bold">«async/await»</div>. 
            <br>
            Ключевое слово <div class="bold">async</div> перед функцией гарантирует, что эта функция
             в любом случае вернёт промис.
             <div class="divider"></div>
             Есть другое ключевое слово – <div class="bold">await</div>, которое можно использовать только внутри async-функций.
             Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, 
             пока промис справа от await не выполнится.
            После чего оно вернёт его результат, и выполнение кода продолжится.

          </div>
        </div>
      </div>


      <div class="block">
        <div class="title"> Методы запросов </div>
        <div class="description">
          <div class="description-par">
            <div class="bold">GET</div> — получение данных с сервера <div class="divider"></div>
            <div class="bold">POST</div> — запрос используется для отправки данных на сервер. <div class="divider"></div>
            <div class="bold">PUT</div> — используется для обновления данных <div class="divider"></div>
            <div class="bold">DELETE</div> — удаление данных на сервере <div class="divider"></div>
            <div class="bold">PATCH</div> - запрос используется для частичного обновления данных на сервере.
          </div>
        </div>
      </div>


      <div class="block">
        <div class="title"> Что такое прототипы в JavaScript</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Прототипы в JavaScript</div> - это механизм позволяющий наследовать объектам, свойства других объектов.
            


          </div>
        </div>
      </div>



    </div>
    <div class="overlay"></div>
    <script src="script.js"></script>
  </body>
</html>
