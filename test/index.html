<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Заметки Фронтендера</title>
  </head>
  <body>
    <div class="menu">
      <div class="menu-right">
        <div class="hamburger">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            fill="currentColor"
          >
            <path
              fill="currentColor"
              fillRule="evenodd"
              d="M0 11a1 1 0 0 1 1-1h22a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1ZM0 19a1 1 0 0 1 1-1h22a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1ZM0 3a1 1 0 0 1 1-1h22a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Z"
              clipRule="evenodd"
            />
          </svg>
        </div>
      </div>
      <div class="count"></div>

    </div>

    <ul class="menu-list">
      <div class="menu-list-svg">
        <?xml version="1.0" encoding="utf-8"?>
        <svg
          fill="#000000"
          width="30px"
          height="30px"
          viewBox="0 0 32 32"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M18.8,16l5.5-5.5c0.8-0.8,0.8-2,0-2.8l0,0C24,7.3,23.5,7,23,7c-0.5,0-1,0.2-1.4,0.6L16,13.2l-5.5-5.5  c-0.8-0.8-2.1-0.8-2.8,0C7.3,8,7,8.5,7,9.1s0.2,1,0.6,1.4l5.5,5.5l-5.5,5.5C7.3,21.9,7,22.4,7,23c0,0.5,0.2,1,0.6,1.4  C8,24.8,8.5,25,9,25c0.5,0,1-0.2,1.4-0.6l5.5-5.5l5.5,5.5c0.8,0.8,2.1,0.8,2.8,0c0.8-0.8,0.8-2.1,0-2.8L18.8,16z"
          />
        </svg>
      </div>
      <li><a href="react.html"> React </a></li>
      <li><a href="typescript.html">Typescript</a></li>
      <li><a href="next.html">Next.js</a></li>
    </ul>

    <div class="container">
      <div class="block">
        <div class="title">Типы данных в JS [8]</div>
        <div class="description">
          <ol class="description-par">
            <li>String</li>
            <li>Number</li>
            <li>Boolean</li>
            <li>Undefined</li>
            <li>Null</li>
            <li>Bigint</li>
            <li>Symbol</li>
            <li>Object</li>
          </ol>
        </div>
      </div>

      <div class="block">
        <div class="title">Ссылочный тип данных / примитивный</div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Ссылочный тип данных</span> отличается от
            примитивного типа данных тем, что переменная, которая содержит
            ссылочный тип данных, не хранит само значение, а лишь ссылку на
            место в памяти.
            <br />
            При присваивании значения другой переменной, она не копирует
            значение, а передает ссылку на место в памяти, где хранится это
            значение.
            <div class="divider"></div>
            А <span class="bold">примитивы</span> хранятся в памяти напрямую в
            переменной, которая содержит это значение. <br />
            При присваивании значения другой переменной, значение переменной
            копируется.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Различие null / Undefined</div>
        <div class="description">
          <div class="description-par">
            <span class="bold"> Undefined </span> - означает, что переменная
            была объявлена но ей не было присвоено какое-либо значение.
            <br />
            <span class="bold">Undefined</span> - также может быть возвращено
            функцией, если она не возвращает явное значение.
            <br />
            <span class="bold">Undefined</span> - является дефолтным значением
            для параметров функции
            <div class="divider"></div>
            <span class="bold">Null</span> - означет, что значение переменной
            явно установлено, как ничего
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Различие function declaration / fn expression</div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Function declaration</span> - объявление функции,
            которое начинается с ключевого слова function, за которым следует
            имя функции, а затем тело самой функции.
            <br />
            Благодаря механизму
            <span class="bold">«Поднятие / Hoisting»</span> данный вид функций
            можно вызывать в любом месте документа.
            <div class="divider"></div>
            <span class="bold">Function expression</span> - эта функция, которая
            объявлена с помощью переменной и не может быть вызвана до ее
            объявления.
            <div class="divider"></div>
            Основная разница заключается в том, что function declaration
            создаются до выполнения кода, в том время, как fn expression
            создается во время выполнения кода.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Различие между const, let, var</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">1.</div>
            Переменные объявленные через
            <span class="bold">var</span> всплывают, это значит, что если мы
            обратимся к переменной еще до момента ее объявления, то получим
            просто undefined в случае же с let и const мы увидем ошибки.
            <div class="divider"></div>
            <div class="bold">2.</div>
            У них есть разная область видимости, у let и const область видимости
            -
            <div class="bold">блочная</div>
            , а у var она функциональная и за блоком var будет все равно
            доступна.
            <div class="divider"></div>
            <div class="bold">3.</div>
            Разница между let и const заключается в том, что переменная
            объявленая через сonst становится константой и по идее ее невозможно
            переопределить, при попытке это сделать мы получим ошибку, при этом
            мы можем изменять значение свойства обьекта объявленные через const,
            но не переопределить полностью объект.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Что такое Hoisting / Поднятие</div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Hoisting</span> - это механизм в JavaScript, в
            котором переменные и объявления функций (fn declaration),
            передвигаются вверх своей области видимости перед тем, как код будет
            выполнен.
            <div class="divider"></div>
            <div class="bold">JavaScript</div>
            - сначала объявляет, а уже затем инициализирует наши переменные, а
            это значит, что к переменным объявленные через var, а также к
            функциям объявленным, как function declaration можно получить доступ
            еще до объявления
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Область видимости «Scope»</div>
        <div class="description">
          <div class="description-par">
            <span class="bold">Область видимости</span> - в JavaScript
            определяет доступность переменных и функций в различных частях кода.
            Область видимости определяет, где и какие переменные и функции могут
            быть использованы в коде.
            <div class="divider"></div>
            Существует 3 типа Областей видимости:
            <br />
            <span class="bold"> 1. Глобальная </span> - переменные и функции в
            данной области становятся глобальными и доступны в любом месте
            документа.
            <div class="divider"></div>
            <span class="bold">2. Фунциональная / локальная</span> - переменные
            и функции объявленные внутри функций доступны только этой функции и
            всем вложенным в нее функциям.
            <div class="divider"></div>
            <span class="bold">3. Блочная область видимости </span> - появилась
            в ES6, для переменных объявленных с помощью let и const, такая
            область видимости находится внутри фигурных скобок так называемого
            блока, даже если это обычный блок if / else, и эти переменные не
            будут доступны за пределом этой области видимости.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Что такое замыкания ? «Closure»</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Замыкание</div>
            возникает, когда функция внутри другой функции использует переменные
            из внешней функции. В этом случае внутренняя функция сохраняет
            ссылку на внешнюю область видимости, и переменные из этой области
            видимости могут быть использованы внутри внутренней функции, даже
            после того, как внешняя функция завершила свою работу.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Что обозначает ключевое слово «this»</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">This</div>
            - это ключевое слово, которое ссылается на текущий объект, в
            контексте которого выполняется код. Значение this зависит от того,
            как вызывается функция или метод.
            <div class="divider"></div>
            Например, если функция вызывается как метод объекта, то this
            ссылается на этот объект. Если функция вызывается без контекста, то
            this ссылается на глобальный объект (window). Если функция
            вызывается с использованием конструктора, то this ссылается на новый
            экземпляр объекта, созданный с помощью конструктора.
            <div class="divider"></div>
            <div class="bold">Стрелочная функция</div>
            не имеет собственного контекста и если в таком случае прописать this
            то ссылаться ключевое слово будет на объект ближайший по иерархии.
            Такая особенность удобна, когда мы хотим передать в функцию внешний
            контекст.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Функция-конструктор</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Функция-конструктор</div>
            - позволяет создавать новые объекты по шаблону на основе других
            данных. При вызове функции конструктора this принимает значение
            вновь созданного объекта, который наполняется вследствие выполнения
            тела функции.
            <div class="code">
              function Student(name, course) { <br />
              this.name = name <br />
              this.course = course <br />
              this.school = 'LearnJS' <br />
              }
              <br />
              let student1 = new Student('Вера', 'JavaScript Basic') <br />
            </div>
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Рекурсия</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Рекурсия</div>
            - это процесс, при котором функция вызывает саму себя в своем теле.
            Для выхода из функции должно быть обязательно условие.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Promise</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Promise</div>
            - это объект, который используется для выполнения асинхронных
            операций и управления их результатами.
            <div class="divider"></div>
            Promise может находиться в трех состояниях: ожидание
            <div class="bold">pending</div>
            , выполнено
            <div class="bold">fulfilled</div>
            или отклонено
            <div class="bold">rejected</div>
            .
            <div class="divider"></div>
            <div class="bold">Promise</div>
            позволяет управлять асинхронными операциями с помощью методов
            then(), catch() и finally().
            <div class="divider"></div>
            <div class="bold">Promise</div>
            получает два аргумента: resolve и reject — это функции, встроенные в
            JavaScript.
            <br />
            <div class="bold">Resolve</div>
            если работа завершилась успешно, с результатом value.
            <br />
            <div class="bold">Reject</div>
            если произошла ошибка, error – объект ошибки.
            <div class="divider"></div>
            Первый аргумент метода
            <div class="bold">.then</div>
            - функция, которая выполняется, когда промис переходит в состояние
            «fulfield», и получает результат.
            <br />
            Второй аргумент
            <div class="bold">.then</div>
            – функция, которая выполняется, когда промис переходит в состояние
            «rejected», и получает ошибку.
            <br />
            <div class="divider"></div>
            Также ошибку мы можем получить в отдельной функции -
            <div class="bold">.catch</div>
            , которая выполняется, когда промис переход в состояние «rejected».
            <br />
            <div class="bold">.finally</div>
            - функция, которая выполнится в любом случае.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Promise API</div>
        <div class="description">
          <div class="description-par">
            <div class="title-text">
              В классе Promise есть несколько статических методов:
            </div>
            <div class="divider"></div>
            <div class="bold">Promise.all</div>
            - принимает массив промисов и возвращает новый промис. Новый промис
            завершится, когда завершится весь переданный список промисов, и его
            результатом будет массив их результатов. Если один промис
            завершается с ошибкой, то весь Promise.all завершается с ней,
            полностью забывая про остальные промисы в списке. Их результаты
            игнорируются.
            <div class="code">let promise = Promise.all(iterable);</div>
            <div class="divider"></div>
            <div class="bold">Promise.race</div>
            - Метод очень похож на Promise.all, но ждёт только первый
            выполненный промис, из которого берёт результат (или ошибку).
            <div class="code">let promise = Promise.race(iterable);</div>
            <div class="divider"></div>
            <div class="bold">Promise.any</div>
            - Метод очень похож на Promise.race, но ждёт только первый успешно
            выполненный промис, из которого берёт результат.
            <br />
            Если ни один из переданных промисов не завершится успешно, тогда
            возвращённый объект Promise будет отклонён с помощью AggregateError
            – специального объекта ошибок, который хранит все ошибки промисов в
            своём свойстве errors.
            <div class="code">let promise = Promise.any(iterable);</div>
            <div class="divider"></div>
            <div class="bold">Promise.resolve(value)</div>
            - создаёт успешно выполненный промис с результатом value.
            <div class="code">
              let promise = new Promise(resolve => resolve(value));
            </div>
            <div class="divider"></div>
            <div class="bold">Promise.reject(error)</div>
            - создаёт промис, завершённый с ошибкой error.
            <div class="code">
              let promise = new Promise((resolve, reject) => reject(error));
            </div>
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Async / await</div>
        <div class="description">
          <div class="description-par">
            Существует специальный синтаксис для работы с промисами, который
            называется
            <div class="bold">«async/await»</div>
            .
            <br />
            Ключевое слово
            <div class="bold">async</div>
            перед функцией гарантирует, что эта функция в любом случае вернёт
            промис.
            <div class="divider"></div>
            Есть другое ключевое слово –
            <div class="bold">await</div>
            , которое можно использовать только внутри async-функций. Ключевое
            слово await заставит интерпретатор JavaScript ждать до тех пор, пока
            промис справа от await не выполнится. После чего оно вернёт его
            результат, и выполнение кода продолжится.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Методы запросов</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">GET</div>
            — получение данных с сервера <br />
            <div class="bold">POST</div>
            — запрос используется для отправки данных на сервер <br />
            <div class="bold">PUT</div>
            — используется для обновления данных <br />
            <div class="bold">DELETE</div>
            — удаление данных на сервере <br />
            <div class="bold">PATCH</div>
            - запрос используется для частичного обновления данных на сервере<br />
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Методы функций</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">bind</div>
            - создает новую функцию, которая связывает указанный объект с
            конекстом вызова функции. Метод также может принимать аргументы,
            которые будут переданы в вызываему функцию. Дальнейшие вызовы
            функции будут вызваны уже с новым контекстом.
            <div class="divider"></div>
            <div class="bold">call</div>
            - вызывает функцию с заданным контекстом, также call может принимать
            аргументы.
            <div class="divider"></div>
            Метод
            <div class="bold">apply</div>
            аналогичен call. Отличие лишь в том, что call принимает список
            аргументов, а apply — массив.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Event Loop</div>
        <div class="description">
          <div class="description-par">
            Начнем с того, что JavaScript является однопоточным языком
            программированием, это значит, что JavaScript может выполнять только
            одну задачу за одну единицу времени.
            <div class="divider"></div>
            <div class="bold">EventLoop</div>
            - или же событийный цикл, механизм, который определяет приоритеты,
            решает какую задачу куда направить и в какой момент времени.
            <div class="divider"></div>
            Существует heap, call stack, WebApi, macrotask и microtask queue.
            <div class="divider"></div>
            <div class="bold">Heap</div>
            - это некий участок памяти, выделяемый, например, под хранение
            объектов.
            <div class="divider"></div>
            <div class="bold">Call stack</div>
            - это то место куда попадает код, затем он выполняется
            <div class="divider"></div>
            <div class="bold">WebApi</div>
            - это интерфейс, предоставляемый браузером. С помощью него мы можем
            взаимодействовать с DOM-деревом, устанавливать таймеры, отслеживать
            клики по элементам, отправлять запросы и тд.
            <div class="divider"></div>
            <div class="bold">Macrotask queue</div>
            - очередь, в которую попадают функции - события таймера, мыши,
            клавиатуры, http запросы
            <div class="divider"></div>
            <div class="bold">Microtask queue [ приоритет ]</div>
            - это очеред микротасок, отличие от макро - микро таски будут
            выполняться до тех пор, пока они есть в очереди, и перед
            макротасками им отдается приоритет. Сюда попадают - Promise и
            MutationObserver
            <div class="divider"></div>
            <div class="bold">MutationObserver</div>
            - это API, предоставляемое браузером, которое позволяет отслеживать
            изменения в DOM-дереве. Он позволяет регистрировать функции
            обратного вызова, которые будут вызываться при любых изменениях в
            элементах DOM.
          </div>
        </div>
      </div>

      <div class="block">
        <div class="title">Прототипы</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">Прототипы в JavaScript</div>
            - это механизм наследования, который позволяет объектам наследовать
            свойства и методы других объектов. Каждый объект в JavaScript имеет
            свойство __proto__, которое указывает на его прототип.
            <div class="bold">Прототип</div>
            - это объект, который содержит свойства и методы, которые могут быть
            унаследованы другими объектами.
            <div class="divider"></div>
            В JavaScript наследование прототипов основано на механизме цепочки
            прототипов. Каждый объект в JavaScript имеет свойство `__proto__`,
            которое ссылается на его прототип. Если при обращении к свойству
            объекта оно не найдено, JavaScript автоматически ищет его в
            прототипе объекта, а затем в прототипе его прототипа и так далее,
            пока не будет найдено или не достигнут конец цепочки прототипов
            (который заканчивается объектом `Object.prototype`, у которого
            `__proto__` равен `null`).
            <div class="divider"></div>
            Что происходит при создании Array, String, Number с точки зрения
            прототипов? <br />
            объект типа Array его прототипом является объект `Array.prototype`,
            который содержит методы и свойства, доступные для всех массивов в
            JavaScript <br />
            Для объектов типа String и Number их прототипом является объект
            `String.prototype` и `Number.prototype`. Они содержат методы и
            свойства, доступные для всех строк и чисел в JavaScript <br />
            <div class="divider"></div>
            Таким образом, при создании объектов типа Array, String и Number
            происходит наследование прототипов, что позволяет им использовать
            методы и свойства из соответствующих прототипов.
          </div>
        </div>
      </div>

      <div class="block" title="Методы массивов">
        <div class="title">Методы массивов</div>
        <div class="description">
          <div class="description-par">
            <div class="title-text">Для добавления/удаления элементов:</div>
            <div class="bold">push</div>
            - добавляет элементы в конец <br />
            <div class="bold">pop</div>
            извлекает элемент с конца<br />
            <div class="bold">length</div>
            - можем узнать длину массива <br />
            <div class="bold">shift</div>
            – извлекает элемент с начала <br />
            <div class="bold">unshift</div>
            – добавляет элементы в начало <br />
            <div class="bold">splice(pos, deleteCount, ...items)</div>
            - начиная с индекса pos удаляет deleteCount элементов и вставляет
            items <br />
            <div class="bold">slice(start, end)</div>
            – создаёт новый массив, копируя в него элементы с индекса start до
            end (не включая end) <br />
            <div class="bold">concat</div>
            – возвращает новый массив: копирует все члены текущего массива и
            добавляет к нему items. Если какой-то из items является массивом,
            тогда берутся его элементы

            <div class="title-text">Для поиска среди элементов:</div>
            <div class="bold">indexOf(item, pos)</div>
            – ищет item, начиная с позиции pos, и возвращает его индекс или -1,
            если ничего не найдено. <br />
            <div class="bold">lastIndexOf</div>
            - позволяет возвратить последний индекс искомого элемента в массиве
            при первом совпадении, или -1 если элемент не найден. <br />
            <div class="bold">includes(value)</div>
            – возвращает true, если в массиве имеется элемент value, в противном
            случае false. <br />
            <div class="bold">find/filter(func)</div>
            – фильтрует элементы через функцию и отдаёт первое/все значения, при
            прохождении которых через функцию возвращается true. <br />
            <div class="bold">findIndex</div>
            похож на find, но возвращает индекс вместо значения. <br />

            <div class="title-text">Для перебора элементов:</div>

            <div class="bold">forEach(func)</div>
            – вызывает func для каждого элемента. Ничего не возвращает.

            <div class="title-text">Для преобразования массива:</div>
            <div class="bold">map(func)</div>
            – создаёт новый массив из результатов вызова func для каждого
            элемента. <br />
            <div class="bold">sort(func)</div>
            – сортирует массив «на месте», а потом возвращает его. <br />
            <div class="bold">reverse</div>
            – «на месте» меняет порядок следования элементов на противоположный
            и возвращает изменённый массив. <br />
            <div class="bold">split</div>
            – он разбивает строку на массив по заданному разделителю. <br />
            <div class="bold">join</div>
            - Он создаёт строку из элементов arr, разделяя их аргументом <br />
            <div class="bold">reduce/reduceRight(func, initial)</div>
            – вычисляет одно значение на основе всего массива, вызывая func для
            каждого элемента и передавая промежуточный результат между вызовами.
            <br />
            <div class="title-text">Дополнительно:</div>
            Array.isArray(arr) проверяет, является ли arr массивом.
          </div>
        </div>
      </div>

      <div class="block" title="Методы строк">
        <div class="title">Методы строк</div>
        <div class="description">
          <div class="description-par">
            Чтобы строки корректно работали с методами, в таком случае создаётся
            специальный «объект-обёртка», который предоставляет нужную
            функциональность, а после удаляется.
            <div class="divider"></div>
            <div class="bold">length</div>
            - помогает узнать длину строки <br />
            <div class="bold">charAt(1)</div>
            - возвращает символ находящийся в указанной позиции в строке <br />
            <div class="bold">toUpperCase()</div>
            - переводит символы строк в верхний регистр <br />
            <div class="bold">toLocaleLowerCase</div>
            - переводит символы строк в нижний регистр <br />
            <div class="bold">indexOf(',')</div>
            - используется для поиска указанного текста в строке, возвращает
            числовой индекс если указанный символ найден, если нет, то
            возвращает -1 <br />
            <div class="bold">lastIndexOf</div>
            - возвращает последний индекс последнего найденого символа <br />
            <div class="divider"></div>
            Все методы занимаются
            <div class="bold">вырезанием строк:</div>
            <br />
            <div class="bold">slice</div>
            - муказываем индекс с которого начинается и заканчивается подстрока
            <br />
            <div class="bold">substr</div>
            - , в качестве второго аргумента принимает не индекс, а длину
            вырезаемых символов <br />
            <div class="bold">substring</div>
            - , не может принимать отрицательно значение <br />
            <div class="bold">replace('Jack', 'Nikita')</div>
            - предназначен для замены значений в строке. <br />
            <div class="bold">trim</div>
            - отсекает пробельные символы в начале и конце строки
          </div>
        </div>
      </div>

      <div class="block" title="Что такое API / Rest API / Restful API">
        <div class="title">Что такое API / Rest API / Restful API</div>
        <div class="description">
          <div class="description-par">
            <div class="bold">API (Application Programming Interface)</div>
            - это набор инструментов и протоколов, которые позволяют различным
            приложениям взаимодействовать друг с другом
            <div class="divider"></div>
            <div class="bold">REST API (Representational State Transfer)</div>
            - это стиль архитектуры, который определяет правила для создания
            веб-сервисов. REST API использует HTTP-протокол для передачи данных
            и поддерживает операции CRUD (Create, Read, Update, Delete) <br />
            <div class="divider"></div>
            Различие между
            <div class="bold">REST API</div>
            и
            <div class="bold">RESTful API</div>
            заключается в том, что RESTful API полностью соответствует принципам
            архитектуры REST, в то время как REST API может не следовать всем
            правилам и ограничениям.
            <div class="divider"></div>
            Таким образом, RESTful API является более строгим и эффективным
            подходом к созданию веб-сервисов, чем просто REST API.
          </div>
        </div>
      </div>
    </div>
    <div class="overlay"></div>
    <script src="script.js"></script>
  </body>
</html>
